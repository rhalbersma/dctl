#pragma once
#include <iterator>                     // bidirectional_iterator_tag, iterator, next, prev
#include <boost/assert.hpp>             // BOOST_ASSERT
#include <boost/operators.hpp>          // equality_comparable1

namespace dctl {
namespace tree {

template<typename BidirectionalIterator>
bool is_next(BidirectionalIterator const& i, BidirectionalIterator const& j)
{
        return std::next(i) == j && std::prev(j) == i;
}

template
<
        typename Node
>
struct bidirectional_iterator
        // http://www.boost.org/doc/libs/1_52_0/libs/utility/operators.htm#chaining
        // use base class chaining to ensure Empty Base Optimization
:       boost::equality_comparable1< bidirectional_iterator<Node>      // == !=
,       std::iterator<std::bidirectional_iterator_tag, typename Node::value_type>
        >
{
private:
        // typedefs

        typedef typename Node::value_type T;
        typedef std::iterator<std::bidirectional_tag, T> Base;

        // dependent names now in scope

        using Base::reference;  // T&
        using Base::pointer;    // T*

public:
        typedef Node& node_ref;
        typedef Node* node_ptr;

        // structors

        bidirectional_iterator()
        :
                pnode_(nullptr)
        {}

        bidirectional_iterator(node_ptr p)
        :
                pnode_(p)
        {}

        // modifiers

        bidirectional_iterator& operator++()
        {
                pnode_ = pnode_->next_;
                return *this;
        }

        bidirectional_iterator operator++(int)
        {
                auto const old = *this;
                ++*this;
                return old;
        }

        bidirectional_iterator& operator--()
        {
                pnode_ = pnode_->prev_;
                return *this;
        }

        bidirectional_iterator operator--(int)
        {
                auto const old = *this;
                --*this;
                return old;
        }

        friend void set_next(bidirectional_iterator& i, bidirectional_iterator& j)
        {
                i.pnode_->next_ = j.pnode_;
                j.pnode_->prev_ = i.pnode_;
                BOOST_ASSERT(is_next(i, j));
        }

        // queries

        reference operator*() const
        {
                return pnode_->value_;
        }

        pointer operator->() const
        {
                return &**this;
        }

        // predicates

        // operator!= automatically generated by boost::equality_comparable1
        friend bool operator==(bidirectional_iterator const& lhs, bidirectional_iterator const& rhs)
        {
                return lhs.pnode_ == rhs.pnode_;
        }

private:
        // representation

        node_ptr pnode_;
};

}       // namespace tree
}       // namespace dctl
